# 🐥 `Step2` 니야의 자동차 경주 리팩토링 - 도밥 피드백 반영 v2 🐥

## `Race` 객체 생성 및 `View` 분리

- 도메인과 뷰를 명확히 분리 가능함.
- 덕분에 `Controller`에서는 `Output` 모듈만 사용되고 `Console` 사용을 없앨 수 있었음. 즉, `Output`과 `Input` 내부에서만 `Console`을 사용하도록 코드가 수정되어 훨씬 깔끔하게 리팩토링됨.
- 다만, 도메인 간 의존성은 좀 더 고려해볼 사항임. 아래는 도밥의 의견인데, 추후 참고할 수 있을만한 부분이라고 판단하여 메모해둠.

```
Race가 관리하는 객체를 딱! 정해서 Car! 라고 정의하지 않는 것부터 시작해볼것 같아요.
우선 RaceGame이 말(player)로 사용할 수 있는 클래스를 받아 생성하도록 개선해볼것 같아요.
이 말(player)은 필드로 position과 name을 가지고, move라는 메서드를 가지면 되겠네요.
이 구성을 만족했다면 그것이 자동차이던, 기차이던, 사람이던 뭐든 다 RaceGame을 구동하는데 사용될 수 있겠네요. 최소한 RaceGame이 직접 말.js를 import 하지 않을 수 있겠네요.
```

## `Race` 클래스 테스트에서 모킹 함수 사용하지 않는 방법

### `playRace`

- `Race` 내부에 랜덤 숫자를 생성하는 함수가 호출될 수 밖에 없기 때문에 `playRace`를 테스트 하려면 어쩔 수 없이 모킹 함수를 사용해야 함. (본 프로그래밍 요구사항)
- 만약 모킹을 하지 않고 테스트하려면, 랜덤으로 인한 결과 값이 고정되지 않는다는 전제 하에, 다른 `Matcher`들을 활용해 간접적으로 테스트를 진행해야 함.

  - 예를 들면, `winners` 배열이 1명 이상 꼭 배출되는 것을 확인 하기 위해 `toBeGreaterThan`를 사용한다든지.
  - 매개변수로 입력 받은 `tryCount`에 따라 라운드 개수, 즉 `playRound`가 `tryCount`만큼 호출된다든지. (사실 이 방법은 `playRound`가 public 함수거나 모킹 함수일때만 가능하므로, `playRace` 반환 배열의 길이를 확인하면 됨.)

### `getWinners`

- `getWinners` 함수는 랜덤 숫자를 생성하는 함수만 피해서 테스트하면 됨.
- 각 자동차 인스턴스의 `move`를 직접 하나씩 호출하여 해당 인스턴스를 사용한 `Race` 객체 인스턴스를 생성한 후, `playRace`를 돌리지 않고 바로 `getWinners` 즉, 우승자를 계산하여 반환하는 로직만 테스트 하는 것.
